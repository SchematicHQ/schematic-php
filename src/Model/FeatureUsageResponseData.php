<?php
/**
 * FeatureUsageResponseData
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  Schematic
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Schematic API
 *
 * Schematic API
 *
 * The version of the OpenAPI document: 0.1
 * Contact: engineering@schematichq.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.2.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Schematic\Model;

use \ArrayAccess;
use \Schematic\ObjectSerializer;

/**
 * FeatureUsageResponseData Class Doc Comment
 *
 * @category Class
 * @package  Schematic
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class FeatureUsageResponseData implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'FeatureUsageResponseData';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'access' => 'bool',
        'allocation' => 'int',
        'allocation_type' => 'EntitlementValueType',
        'company_override' => '\Schematic\Model\CompanyOverrideResponseData',
        'credit_consumption_rate' => 'float',
        'credit_grant_counts' => 'array<string,float>',
        'credit_grant_details' => '\Schematic\Model\CreditGrantDetail[]',
        'credit_grant_reason' => 'BillingCreditGrantReason',
        'credit_remaining' => 'float',
        'credit_total' => 'float',
        'credit_type_icon' => 'string',
        'credit_usage_aggregation' => '\Schematic\Model\FeatureCompanyResponseDataCreditUsageAggregation',
        'credit_used' => 'float',
        'effective_limit' => 'int',
        'effective_price' => 'float',
        'entitlement_expiration_date' => '\DateTime',
        'entitlement_id' => 'string',
        'entitlement_source' => 'string',
        'entitlement_type' => '\Schematic\Model\EntitlementType',
        'feature' => '\Schematic\Model\FeatureDetailResponseData',
        'has_valid_allocation' => 'bool',
        'is_unlimited' => 'bool',
        'metric_reset_at' => '\DateTime',
        'month_reset' => 'string',
        'monthly_usage_based_price' => '\Schematic\Model\BillingPriceView',
        'overuse' => 'int',
        'percent_used' => 'float',
        'period' => 'string',
        'plan' => '\Schematic\Model\PlanResponseData',
        'plan_entitlement' => '\Schematic\Model\PlanEntitlementResponseData',
        'price_behavior' => '\Schematic\Model\EntitlementPriceBehavior',
        'soft_limit' => 'int',
        'usage' => 'int',
        'yearly_usage_based_price' => '\Schematic\Model\BillingPriceView'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'access' => null,
        'allocation' => null,
        'allocation_type' => null,
        'company_override' => null,
        'credit_consumption_rate' => null,
        'credit_grant_counts' => null,
        'credit_grant_details' => null,
        'credit_grant_reason' => null,
        'credit_remaining' => null,
        'credit_total' => null,
        'credit_type_icon' => null,
        'credit_usage_aggregation' => null,
        'credit_used' => null,
        'effective_limit' => null,
        'effective_price' => null,
        'entitlement_expiration_date' => 'date-time',
        'entitlement_id' => null,
        'entitlement_source' => null,
        'entitlement_type' => null,
        'feature' => null,
        'has_valid_allocation' => null,
        'is_unlimited' => null,
        'metric_reset_at' => 'date-time',
        'month_reset' => null,
        'monthly_usage_based_price' => null,
        'overuse' => null,
        'percent_used' => null,
        'period' => null,
        'plan' => null,
        'plan_entitlement' => null,
        'price_behavior' => null,
        'soft_limit' => null,
        'usage' => null,
        'yearly_usage_based_price' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'access' => false,
        'allocation' => true,
        'allocation_type' => false,
        'company_override' => false,
        'credit_consumption_rate' => true,
        'credit_grant_counts' => false,
        'credit_grant_details' => false,
        'credit_grant_reason' => true,
        'credit_remaining' => true,
        'credit_total' => true,
        'credit_type_icon' => true,
        'credit_usage_aggregation' => false,
        'credit_used' => true,
        'effective_limit' => true,
        'effective_price' => true,
        'entitlement_expiration_date' => true,
        'entitlement_id' => false,
        'entitlement_source' => true,
        'entitlement_type' => false,
        'feature' => false,
        'has_valid_allocation' => true,
        'is_unlimited' => true,
        'metric_reset_at' => true,
        'month_reset' => true,
        'monthly_usage_based_price' => false,
        'overuse' => true,
        'percent_used' => true,
        'period' => true,
        'plan' => false,
        'plan_entitlement' => false,
        'price_behavior' => true,
        'soft_limit' => true,
        'usage' => true,
        'yearly_usage_based_price' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'access' => 'access',
        'allocation' => 'allocation',
        'allocation_type' => 'allocation_type',
        'company_override' => 'company_override',
        'credit_consumption_rate' => 'credit_consumption_rate',
        'credit_grant_counts' => 'credit_grant_counts',
        'credit_grant_details' => 'credit_grant_details',
        'credit_grant_reason' => 'credit_grant_reason',
        'credit_remaining' => 'credit_remaining',
        'credit_total' => 'credit_total',
        'credit_type_icon' => 'credit_type_icon',
        'credit_usage_aggregation' => 'credit_usage_aggregation',
        'credit_used' => 'credit_used',
        'effective_limit' => 'effective_limit',
        'effective_price' => 'effective_price',
        'entitlement_expiration_date' => 'entitlement_expiration_date',
        'entitlement_id' => 'entitlement_id',
        'entitlement_source' => 'entitlement_source',
        'entitlement_type' => 'entitlement_type',
        'feature' => 'feature',
        'has_valid_allocation' => 'has_valid_allocation',
        'is_unlimited' => 'is_unlimited',
        'metric_reset_at' => 'metric_reset_at',
        'month_reset' => 'month_reset',
        'monthly_usage_based_price' => 'monthly_usage_based_price',
        'overuse' => 'overuse',
        'percent_used' => 'percent_used',
        'period' => 'period',
        'plan' => 'plan',
        'plan_entitlement' => 'plan_entitlement',
        'price_behavior' => 'price_behavior',
        'soft_limit' => 'soft_limit',
        'usage' => 'usage',
        'yearly_usage_based_price' => 'yearly_usage_based_price'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'access' => 'setAccess',
        'allocation' => 'setAllocation',
        'allocation_type' => 'setAllocationType',
        'company_override' => 'setCompanyOverride',
        'credit_consumption_rate' => 'setCreditConsumptionRate',
        'credit_grant_counts' => 'setCreditGrantCounts',
        'credit_grant_details' => 'setCreditGrantDetails',
        'credit_grant_reason' => 'setCreditGrantReason',
        'credit_remaining' => 'setCreditRemaining',
        'credit_total' => 'setCreditTotal',
        'credit_type_icon' => 'setCreditTypeIcon',
        'credit_usage_aggregation' => 'setCreditUsageAggregation',
        'credit_used' => 'setCreditUsed',
        'effective_limit' => 'setEffectiveLimit',
        'effective_price' => 'setEffectivePrice',
        'entitlement_expiration_date' => 'setEntitlementExpirationDate',
        'entitlement_id' => 'setEntitlementId',
        'entitlement_source' => 'setEntitlementSource',
        'entitlement_type' => 'setEntitlementType',
        'feature' => 'setFeature',
        'has_valid_allocation' => 'setHasValidAllocation',
        'is_unlimited' => 'setIsUnlimited',
        'metric_reset_at' => 'setMetricResetAt',
        'month_reset' => 'setMonthReset',
        'monthly_usage_based_price' => 'setMonthlyUsageBasedPrice',
        'overuse' => 'setOveruse',
        'percent_used' => 'setPercentUsed',
        'period' => 'setPeriod',
        'plan' => 'setPlan',
        'plan_entitlement' => 'setPlanEntitlement',
        'price_behavior' => 'setPriceBehavior',
        'soft_limit' => 'setSoftLimit',
        'usage' => 'setUsage',
        'yearly_usage_based_price' => 'setYearlyUsageBasedPrice'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'access' => 'getAccess',
        'allocation' => 'getAllocation',
        'allocation_type' => 'getAllocationType',
        'company_override' => 'getCompanyOverride',
        'credit_consumption_rate' => 'getCreditConsumptionRate',
        'credit_grant_counts' => 'getCreditGrantCounts',
        'credit_grant_details' => 'getCreditGrantDetails',
        'credit_grant_reason' => 'getCreditGrantReason',
        'credit_remaining' => 'getCreditRemaining',
        'credit_total' => 'getCreditTotal',
        'credit_type_icon' => 'getCreditTypeIcon',
        'credit_usage_aggregation' => 'getCreditUsageAggregation',
        'credit_used' => 'getCreditUsed',
        'effective_limit' => 'getEffectiveLimit',
        'effective_price' => 'getEffectivePrice',
        'entitlement_expiration_date' => 'getEntitlementExpirationDate',
        'entitlement_id' => 'getEntitlementId',
        'entitlement_source' => 'getEntitlementSource',
        'entitlement_type' => 'getEntitlementType',
        'feature' => 'getFeature',
        'has_valid_allocation' => 'getHasValidAllocation',
        'is_unlimited' => 'getIsUnlimited',
        'metric_reset_at' => 'getMetricResetAt',
        'month_reset' => 'getMonthReset',
        'monthly_usage_based_price' => 'getMonthlyUsageBasedPrice',
        'overuse' => 'getOveruse',
        'percent_used' => 'getPercentUsed',
        'period' => 'getPeriod',
        'plan' => 'getPlan',
        'plan_entitlement' => 'getPlanEntitlement',
        'price_behavior' => 'getPriceBehavior',
        'soft_limit' => 'getSoftLimit',
        'usage' => 'getUsage',
        'yearly_usage_based_price' => 'getYearlyUsageBasedPrice'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('access', $data ?? [], null);
        $this->setIfExists('allocation', $data ?? [], null);
        $this->setIfExists('allocation_type', $data ?? [], null);
        $this->setIfExists('company_override', $data ?? [], null);
        $this->setIfExists('credit_consumption_rate', $data ?? [], null);
        $this->setIfExists('credit_grant_counts', $data ?? [], null);
        $this->setIfExists('credit_grant_details', $data ?? [], null);
        $this->setIfExists('credit_grant_reason', $data ?? [], null);
        $this->setIfExists('credit_remaining', $data ?? [], null);
        $this->setIfExists('credit_total', $data ?? [], null);
        $this->setIfExists('credit_type_icon', $data ?? [], null);
        $this->setIfExists('credit_usage_aggregation', $data ?? [], null);
        $this->setIfExists('credit_used', $data ?? [], null);
        $this->setIfExists('effective_limit', $data ?? [], null);
        $this->setIfExists('effective_price', $data ?? [], null);
        $this->setIfExists('entitlement_expiration_date', $data ?? [], null);
        $this->setIfExists('entitlement_id', $data ?? [], null);
        $this->setIfExists('entitlement_source', $data ?? [], null);
        $this->setIfExists('entitlement_type', $data ?? [], null);
        $this->setIfExists('feature', $data ?? [], null);
        $this->setIfExists('has_valid_allocation', $data ?? [], null);
        $this->setIfExists('is_unlimited', $data ?? [], null);
        $this->setIfExists('metric_reset_at', $data ?? [], null);
        $this->setIfExists('month_reset', $data ?? [], null);
        $this->setIfExists('monthly_usage_based_price', $data ?? [], null);
        $this->setIfExists('overuse', $data ?? [], null);
        $this->setIfExists('percent_used', $data ?? [], null);
        $this->setIfExists('period', $data ?? [], null);
        $this->setIfExists('plan', $data ?? [], null);
        $this->setIfExists('plan_entitlement', $data ?? [], null);
        $this->setIfExists('price_behavior', $data ?? [], null);
        $this->setIfExists('soft_limit', $data ?? [], null);
        $this->setIfExists('usage', $data ?? [], null);
        $this->setIfExists('yearly_usage_based_price', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['access'] === null) {
            $invalidProperties[] = "'access' can't be null";
        }
        if ($this->container['allocation_type'] === null) {
            $invalidProperties[] = "'allocation_type' can't be null";
        }
        if ($this->container['entitlement_id'] === null) {
            $invalidProperties[] = "'entitlement_id' can't be null";
        }
        if ($this->container['entitlement_type'] === null) {
            $invalidProperties[] = "'entitlement_type' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets access
     *
     * @return bool
     */
    public function getAccess()
    {
        return $this->container['access'];
    }

    /**
     * Sets access
     *
     * @param bool $access Whether further usage is permitted.
     *
     * @return self
     */
    public function setAccess($access)
    {
        if (is_null($access)) {
            throw new \InvalidArgumentException('non-nullable access cannot be null');
        }
        $this->container['access'] = $access;

        return $this;
    }

    /**
     * Gets allocation
     *
     * @return int|null
     */
    public function getAllocation()
    {
        return $this->container['allocation'];
    }

    /**
     * Sets allocation
     *
     * @param int|null $allocation The maximum amount of usage that is permitted; a null value indicates that unlimited usage is permitted or that this is a credit-based entitlement (use credit_remaining instead).
     *
     * @return self
     */
    public function setAllocation($allocation)
    {
        if (is_null($allocation)) {
            array_push($this->openAPINullablesSetToNull, 'allocation');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('allocation', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['allocation'] = $allocation;

        return $this;
    }

    /**
     * Gets allocation_type
     *
     * @return EntitlementValueType
     */
    public function getAllocationType()
    {
        return $this->container['allocation_type'];
    }

    /**
     * Sets allocation_type
     *
     * @param EntitlementValueType $allocation_type allocation_type
     *
     * @return self
     */
    public function setAllocationType($allocation_type)
    {
        if (is_null($allocation_type)) {
            throw new \InvalidArgumentException('non-nullable allocation_type cannot be null');
        }
        $this->container['allocation_type'] = $allocation_type;

        return $this;
    }

    /**
     * Gets company_override
     *
     * @return \Schematic\Model\CompanyOverrideResponseData|null
     */
    public function getCompanyOverride()
    {
        return $this->container['company_override'];
    }

    /**
     * Sets company_override
     *
     * @param \Schematic\Model\CompanyOverrideResponseData|null $company_override company_override
     *
     * @return self
     */
    public function setCompanyOverride($company_override)
    {
        if (is_null($company_override)) {
            throw new \InvalidArgumentException('non-nullable company_override cannot be null');
        }
        $this->container['company_override'] = $company_override;

        return $this;
    }

    /**
     * Gets credit_consumption_rate
     *
     * @return float|null
     */
    public function getCreditConsumptionRate()
    {
        return $this->container['credit_consumption_rate'];
    }

    /**
     * Sets credit_consumption_rate
     *
     * @param float|null $credit_consumption_rate The rate at which credits are consumed per unit of usage
     *
     * @return self
     */
    public function setCreditConsumptionRate($credit_consumption_rate)
    {
        if (is_null($credit_consumption_rate)) {
            array_push($this->openAPINullablesSetToNull, 'credit_consumption_rate');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('credit_consumption_rate', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['credit_consumption_rate'] = $credit_consumption_rate;

        return $this;
    }

    /**
     * Gets credit_grant_counts
     *
     * @return array<string,float>|null
     */
    public function getCreditGrantCounts()
    {
        return $this->container['credit_grant_counts'];
    }

    /**
     * Sets credit_grant_counts
     *
     * @param array<string,float>|null $credit_grant_counts credit_grant_counts
     *
     * @return self
     */
    public function setCreditGrantCounts($credit_grant_counts)
    {
        if (is_null($credit_grant_counts)) {
            throw new \InvalidArgumentException('non-nullable credit_grant_counts cannot be null');
        }
        $this->container['credit_grant_counts'] = $credit_grant_counts;

        return $this;
    }

    /**
     * Gets credit_grant_details
     *
     * @return \Schematic\Model\CreditGrantDetail[]|null
     */
    public function getCreditGrantDetails()
    {
        return $this->container['credit_grant_details'];
    }

    /**
     * Sets credit_grant_details
     *
     * @param \Schematic\Model\CreditGrantDetail[]|null $credit_grant_details credit_grant_details
     *
     * @return self
     */
    public function setCreditGrantDetails($credit_grant_details)
    {
        if (is_null($credit_grant_details)) {
            throw new \InvalidArgumentException('non-nullable credit_grant_details cannot be null');
        }
        $this->container['credit_grant_details'] = $credit_grant_details;

        return $this;
    }

    /**
     * Gets credit_grant_reason
     *
     * @return BillingCreditGrantReason|null
     */
    public function getCreditGrantReason()
    {
        return $this->container['credit_grant_reason'];
    }

    /**
     * Sets credit_grant_reason
     *
     * @param BillingCreditGrantReason|null $credit_grant_reason credit_grant_reason
     *
     * @return self
     */
    public function setCreditGrantReason($credit_grant_reason)
    {
        if (is_null($credit_grant_reason)) {
            array_push($this->openAPINullablesSetToNull, 'credit_grant_reason');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('credit_grant_reason', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['credit_grant_reason'] = $credit_grant_reason;

        return $this;
    }

    /**
     * Gets credit_remaining
     *
     * @return float|null
     */
    public function getCreditRemaining()
    {
        return $this->container['credit_remaining'];
    }

    /**
     * Sets credit_remaining
     *
     * @param float|null $credit_remaining credit_remaining
     *
     * @return self
     */
    public function setCreditRemaining($credit_remaining)
    {
        if (is_null($credit_remaining)) {
            array_push($this->openAPINullablesSetToNull, 'credit_remaining');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('credit_remaining', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['credit_remaining'] = $credit_remaining;

        return $this;
    }

    /**
     * Gets credit_total
     *
     * @return float|null
     * @deprecated
     */
    public function getCreditTotal()
    {
        return $this->container['credit_total'];
    }

    /**
     * Sets credit_total
     *
     * @param float|null $credit_total Deprecated: Use credit_remaining instead.
     *
     * @return self
     * @deprecated
     */
    public function setCreditTotal($credit_total)
    {
        if (is_null($credit_total)) {
            array_push($this->openAPINullablesSetToNull, 'credit_total');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('credit_total', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['credit_total'] = $credit_total;

        return $this;
    }

    /**
     * Gets credit_type_icon
     *
     * @return string|null
     */
    public function getCreditTypeIcon()
    {
        return $this->container['credit_type_icon'];
    }

    /**
     * Sets credit_type_icon
     *
     * @param string|null $credit_type_icon Icon identifier for the credit type
     *
     * @return self
     */
    public function setCreditTypeIcon($credit_type_icon)
    {
        if (is_null($credit_type_icon)) {
            array_push($this->openAPINullablesSetToNull, 'credit_type_icon');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('credit_type_icon', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['credit_type_icon'] = $credit_type_icon;

        return $this;
    }

    /**
     * Gets credit_usage_aggregation
     *
     * @return \Schematic\Model\FeatureCompanyResponseDataCreditUsageAggregation|null
     */
    public function getCreditUsageAggregation()
    {
        return $this->container['credit_usage_aggregation'];
    }

    /**
     * Sets credit_usage_aggregation
     *
     * @param \Schematic\Model\FeatureCompanyResponseDataCreditUsageAggregation|null $credit_usage_aggregation credit_usage_aggregation
     *
     * @return self
     */
    public function setCreditUsageAggregation($credit_usage_aggregation)
    {
        if (is_null($credit_usage_aggregation)) {
            throw new \InvalidArgumentException('non-nullable credit_usage_aggregation cannot be null');
        }
        $this->container['credit_usage_aggregation'] = $credit_usage_aggregation;

        return $this;
    }

    /**
     * Gets credit_used
     *
     * @return float|null
     */
    public function getCreditUsed()
    {
        return $this->container['credit_used'];
    }

    /**
     * Sets credit_used
     *
     * @param float|null $credit_used credit_used
     *
     * @return self
     */
    public function setCreditUsed($credit_used)
    {
        if (is_null($credit_used)) {
            array_push($this->openAPINullablesSetToNull, 'credit_used');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('credit_used', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['credit_used'] = $credit_used;

        return $this;
    }

    /**
     * Gets effective_limit
     *
     * @return int|null
     */
    public function getEffectiveLimit()
    {
        return $this->container['effective_limit'];
    }

    /**
     * Sets effective_limit
     *
     * @param int|null $effective_limit Effective limit for usage calculations. For overage pricing, this is the soft limit where overage charges begin. For tiered pricing, this is the first tier boundary. For other pricing models, this is the base allocation. Used to calculate usage percentages and determine access thresholds.
     *
     * @return self
     */
    public function setEffectiveLimit($effective_limit)
    {
        if (is_null($effective_limit)) {
            array_push($this->openAPINullablesSetToNull, 'effective_limit');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('effective_limit', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['effective_limit'] = $effective_limit;

        return $this;
    }

    /**
     * Gets effective_price
     *
     * @return float|null
     */
    public function getEffectivePrice()
    {
        return $this->container['effective_price'];
    }

    /**
     * Sets effective_price
     *
     * @param float|null $effective_price Per-unit price for current usage scenario
     *
     * @return self
     */
    public function setEffectivePrice($effective_price)
    {
        if (is_null($effective_price)) {
            array_push($this->openAPINullablesSetToNull, 'effective_price');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('effective_price', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['effective_price'] = $effective_price;

        return $this;
    }

    /**
     * Gets entitlement_expiration_date
     *
     * @return \DateTime|null
     */
    public function getEntitlementExpirationDate()
    {
        return $this->container['entitlement_expiration_date'];
    }

    /**
     * Sets entitlement_expiration_date
     *
     * @param \DateTime|null $entitlement_expiration_date entitlement_expiration_date
     *
     * @return self
     */
    public function setEntitlementExpirationDate($entitlement_expiration_date)
    {
        if (is_null($entitlement_expiration_date)) {
            array_push($this->openAPINullablesSetToNull, 'entitlement_expiration_date');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('entitlement_expiration_date', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['entitlement_expiration_date'] = $entitlement_expiration_date;

        return $this;
    }

    /**
     * Gets entitlement_id
     *
     * @return string
     */
    public function getEntitlementId()
    {
        return $this->container['entitlement_id'];
    }

    /**
     * Sets entitlement_id
     *
     * @param string $entitlement_id entitlement_id
     *
     * @return self
     */
    public function setEntitlementId($entitlement_id)
    {
        if (is_null($entitlement_id)) {
            throw new \InvalidArgumentException('non-nullable entitlement_id cannot be null');
        }
        $this->container['entitlement_id'] = $entitlement_id;

        return $this;
    }

    /**
     * Gets entitlement_source
     *
     * @return string|null
     */
    public function getEntitlementSource()
    {
        return $this->container['entitlement_source'];
    }

    /**
     * Sets entitlement_source
     *
     * @param string|null $entitlement_source Source of the entitlement (plan or company_override)
     *
     * @return self
     */
    public function setEntitlementSource($entitlement_source)
    {
        if (is_null($entitlement_source)) {
            array_push($this->openAPINullablesSetToNull, 'entitlement_source');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('entitlement_source', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['entitlement_source'] = $entitlement_source;

        return $this;
    }

    /**
     * Gets entitlement_type
     *
     * @return \Schematic\Model\EntitlementType
     */
    public function getEntitlementType()
    {
        return $this->container['entitlement_type'];
    }

    /**
     * Sets entitlement_type
     *
     * @param \Schematic\Model\EntitlementType $entitlement_type entitlement_type
     *
     * @return self
     */
    public function setEntitlementType($entitlement_type)
    {
        if (is_null($entitlement_type)) {
            throw new \InvalidArgumentException('non-nullable entitlement_type cannot be null');
        }
        $this->container['entitlement_type'] = $entitlement_type;

        return $this;
    }

    /**
     * Gets feature
     *
     * @return \Schematic\Model\FeatureDetailResponseData|null
     */
    public function getFeature()
    {
        return $this->container['feature'];
    }

    /**
     * Sets feature
     *
     * @param \Schematic\Model\FeatureDetailResponseData|null $feature feature
     *
     * @return self
     */
    public function setFeature($feature)
    {
        if (is_null($feature)) {
            throw new \InvalidArgumentException('non-nullable feature cannot be null');
        }
        $this->container['feature'] = $feature;

        return $this;
    }

    /**
     * Gets has_valid_allocation
     *
     * @return bool|null
     */
    public function getHasValidAllocation()
    {
        return $this->container['has_valid_allocation'];
    }

    /**
     * Sets has_valid_allocation
     *
     * @param bool|null $has_valid_allocation Whether a valid allocation exists
     *
     * @return self
     */
    public function setHasValidAllocation($has_valid_allocation)
    {
        if (is_null($has_valid_allocation)) {
            array_push($this->openAPINullablesSetToNull, 'has_valid_allocation');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('has_valid_allocation', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['has_valid_allocation'] = $has_valid_allocation;

        return $this;
    }

    /**
     * Gets is_unlimited
     *
     * @return bool|null
     */
    public function getIsUnlimited()
    {
        return $this->container['is_unlimited'];
    }

    /**
     * Sets is_unlimited
     *
     * @param bool|null $is_unlimited Whether this is an unlimited allocation
     *
     * @return self
     */
    public function setIsUnlimited($is_unlimited)
    {
        if (is_null($is_unlimited)) {
            array_push($this->openAPINullablesSetToNull, 'is_unlimited');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('is_unlimited', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['is_unlimited'] = $is_unlimited;

        return $this;
    }

    /**
     * Gets metric_reset_at
     *
     * @return \DateTime|null
     */
    public function getMetricResetAt()
    {
        return $this->container['metric_reset_at'];
    }

    /**
     * Sets metric_reset_at
     *
     * @param \DateTime|null $metric_reset_at The time at which the metric will reset.
     *
     * @return self
     */
    public function setMetricResetAt($metric_reset_at)
    {
        if (is_null($metric_reset_at)) {
            array_push($this->openAPINullablesSetToNull, 'metric_reset_at');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('metric_reset_at', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['metric_reset_at'] = $metric_reset_at;

        return $this;
    }

    /**
     * Gets month_reset
     *
     * @return string|null
     */
    public function getMonthReset()
    {
        return $this->container['month_reset'];
    }

    /**
     * Sets month_reset
     *
     * @param string|null $month_reset If the period is current_month, when the month resets.
     *
     * @return self
     */
    public function setMonthReset($month_reset)
    {
        if (is_null($month_reset)) {
            array_push($this->openAPINullablesSetToNull, 'month_reset');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('month_reset', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['month_reset'] = $month_reset;

        return $this;
    }

    /**
     * Gets monthly_usage_based_price
     *
     * @return \Schematic\Model\BillingPriceView|null
     */
    public function getMonthlyUsageBasedPrice()
    {
        return $this->container['monthly_usage_based_price'];
    }

    /**
     * Sets monthly_usage_based_price
     *
     * @param \Schematic\Model\BillingPriceView|null $monthly_usage_based_price monthly_usage_based_price
     *
     * @return self
     */
    public function setMonthlyUsageBasedPrice($monthly_usage_based_price)
    {
        if (is_null($monthly_usage_based_price)) {
            throw new \InvalidArgumentException('non-nullable monthly_usage_based_price cannot be null');
        }
        $this->container['monthly_usage_based_price'] = $monthly_usage_based_price;

        return $this;
    }

    /**
     * Gets overuse
     *
     * @return int|null
     */
    public function getOveruse()
    {
        return $this->container['overuse'];
    }

    /**
     * Sets overuse
     *
     * @param int|null $overuse Amount of usage exceeding soft limit (overage pricing only)
     *
     * @return self
     */
    public function setOveruse($overuse)
    {
        if (is_null($overuse)) {
            array_push($this->openAPINullablesSetToNull, 'overuse');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('overuse', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['overuse'] = $overuse;

        return $this;
    }

    /**
     * Gets percent_used
     *
     * @return float|null
     */
    public function getPercentUsed()
    {
        return $this->container['percent_used'];
    }

    /**
     * Sets percent_used
     *
     * @param float|null $percent_used Percentage of allocation consumed (0-100+)
     *
     * @return self
     */
    public function setPercentUsed($percent_used)
    {
        if (is_null($percent_used)) {
            array_push($this->openAPINullablesSetToNull, 'percent_used');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('percent_used', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['percent_used'] = $percent_used;

        return $this;
    }

    /**
     * Gets period
     *
     * @return string|null
     */
    public function getPeriod()
    {
        return $this->container['period'];
    }

    /**
     * Sets period
     *
     * @param string|null $period The period over which usage is measured.
     *
     * @return self
     */
    public function setPeriod($period)
    {
        if (is_null($period)) {
            array_push($this->openAPINullablesSetToNull, 'period');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('period', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['period'] = $period;

        return $this;
    }

    /**
     * Gets plan
     *
     * @return \Schematic\Model\PlanResponseData|null
     */
    public function getPlan()
    {
        return $this->container['plan'];
    }

    /**
     * Sets plan
     *
     * @param \Schematic\Model\PlanResponseData|null $plan plan
     *
     * @return self
     */
    public function setPlan($plan)
    {
        if (is_null($plan)) {
            throw new \InvalidArgumentException('non-nullable plan cannot be null');
        }
        $this->container['plan'] = $plan;

        return $this;
    }

    /**
     * Gets plan_entitlement
     *
     * @return \Schematic\Model\PlanEntitlementResponseData|null
     */
    public function getPlanEntitlement()
    {
        return $this->container['plan_entitlement'];
    }

    /**
     * Sets plan_entitlement
     *
     * @param \Schematic\Model\PlanEntitlementResponseData|null $plan_entitlement plan_entitlement
     *
     * @return self
     */
    public function setPlanEntitlement($plan_entitlement)
    {
        if (is_null($plan_entitlement)) {
            throw new \InvalidArgumentException('non-nullable plan_entitlement cannot be null');
        }
        $this->container['plan_entitlement'] = $plan_entitlement;

        return $this;
    }

    /**
     * Gets price_behavior
     *
     * @return \Schematic\Model\EntitlementPriceBehavior|null
     */
    public function getPriceBehavior()
    {
        return $this->container['price_behavior'];
    }

    /**
     * Sets price_behavior
     *
     * @param \Schematic\Model\EntitlementPriceBehavior|null $price_behavior price_behavior
     *
     * @return self
     */
    public function setPriceBehavior($price_behavior)
    {
        if (is_null($price_behavior)) {
            array_push($this->openAPINullablesSetToNull, 'price_behavior');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('price_behavior', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['price_behavior'] = $price_behavior;

        return $this;
    }

    /**
     * Gets soft_limit
     *
     * @return int|null
     */
    public function getSoftLimit()
    {
        return $this->container['soft_limit'];
    }

    /**
     * Sets soft_limit
     *
     * @param int|null $soft_limit The soft limit for the feature usage. Available only for overage price behavior
     *
     * @return self
     */
    public function setSoftLimit($soft_limit)
    {
        if (is_null($soft_limit)) {
            array_push($this->openAPINullablesSetToNull, 'soft_limit');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('soft_limit', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['soft_limit'] = $soft_limit;

        return $this;
    }

    /**
     * Gets usage
     *
     * @return int|null
     */
    public function getUsage()
    {
        return $this->container['usage'];
    }

    /**
     * Sets usage
     *
     * @param int|null $usage The amount of usage that has been consumed; a null value indicates that usage is not being measured or that this is a credit-based entitlement (use credit_used instead).
     *
     * @return self
     */
    public function setUsage($usage)
    {
        if (is_null($usage)) {
            array_push($this->openAPINullablesSetToNull, 'usage');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('usage', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['usage'] = $usage;

        return $this;
    }

    /**
     * Gets yearly_usage_based_price
     *
     * @return \Schematic\Model\BillingPriceView|null
     */
    public function getYearlyUsageBasedPrice()
    {
        return $this->container['yearly_usage_based_price'];
    }

    /**
     * Sets yearly_usage_based_price
     *
     * @param \Schematic\Model\BillingPriceView|null $yearly_usage_based_price yearly_usage_based_price
     *
     * @return self
     */
    public function setYearlyUsageBasedPrice($yearly_usage_based_price)
    {
        if (is_null($yearly_usage_based_price)) {
            throw new \InvalidArgumentException('non-nullable yearly_usage_based_price cannot be null');
        }
        $this->container['yearly_usage_based_price'] = $yearly_usage_based_price;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


